# Решение тестового задания

По задачи у нас уже есть БД и проблема в его пропускной способности. Операций чтения гораздо больше чем записи. Поэтому я выбрал денормализацию. Она даст скорость операций в разы(5-10) больше.

## Контекст
- Используется документоориентированная БД
- Интерфейс БД (IDb) является внешним контрактом и не может быть изменён
- Количество операций чтения значительно превышает количество операций записи
- Узкое место по производительности — БД

## Архитектура
Приложение разделил на слои для удобства рефакторинга и понимания:
- types — типизация элементов
- repositories — доступ к БД
- db — изначальный файл db
- services — бизнес-логика
- ___tests___ — тесты для проверки работоспособности

## Модель данных
Для read-heavy(много чтения/мало записей) сценария используется денормализованная модель Employee.
Employee содержит:
- идентификаторы связанных сущностей
- человекочитаемые поля (cityName, positionName, divisionName)

## Тестирование
Используются:
- unit-тесты (Jest) для проверки бизнес-логики
- edge-case тесты для проверки устойчивости
- сценарный (manual) тест для демонстрации работы сервиса

Реальная БД не используется, зависимости замоканы.

## Update
Метод update не реализован согласно заданию.
При реализации потребовал бы каскадного обновления
денормализованных данных или использования событий.

## Удалил
- Убрал шаблонные данные elementSource из примера

## Ответ на вопрос 3
- Да, решение изменилось бы. Если же чтения редкие, а записи — частые, стоит выбрать нормализлванную структуру. Сущности будут храниться отдельно, а при чтении выполняются соединения (джойны) или сбор данных на уровне приложения. Это упрощает обновления и снижает нагрузку при частых записях. 
Можно подключить кэширование для редких чтений, чтобы немного ускорить.

## Контакты
Бирюков Александр
Telegram: @jacklex_x
